
# Measuring FFT Performance on an AVR Microcontroller
## Abstract
In this document we're demonstrating the ability of an AVR MCU to run a third-party FFT library (kissFFT) and quantify its performance. 

## Intro
The Fast Fourier Transformation (FFT) is a versatile tool for signal analysis. The general idea, in terms of electronic signals, is to de-compose a given signal (in the time domain) into sinus-shaped components (in the frequency domain). Each component has a frequency, a phase, and an amplitude. The inverse operation is adding all components and will return a signal that is, in a theoretical limit, identical to the original input signal. 
By observing the parameters of the components, FFT can serve as a filtering tool, and isolate a periodic signal in noisy environment, detect frequency shifts of a signal, or simply distinguish amplitudes in high and low frequency bands for controlling your disco lights.

The versatility and usefulness of FFT has lead to many implementations in form of libraries and re-usable code. Generally speaking, FFT libraries can focus on different main criteria: speed, mathematical properties such as supported dimensionality or data types, code properties such as simplicity, code size, or which programming language is used. Supported architectures/compilers and licensing models certainly play a role, too.

## FFT Library
We chose kissFFT, which focuses on simplicity and compactness. It is easy to integrate into an AVR project, implemented in C, and has a useful licensing model. On the other hand, there are no  windowing functions (aside from the implicit rectangular window when picking data blocks out of a stream), and there are hardly any features such as peak localization - this is fully up to the application.
You may prefer different criteria for your library, or even implement your own FFT functions, but the general upshots from this document are also valid there.


## Parameters
The actual properties of the input data are determined by the application; here we are using signed 16-bit integers, as they would be generated by a 10- or 12-bit ADC with differential input: 
	• int16_t is the internal type within kissFFT anyway. 
	• A one-dimensional set of real numbers is a typical evolution of a sensor signal over time.
	• Time and frequency can be deduced from MCU- and ADC- parameters outside the FFT library.
	• The size of the input data arrays was varied in length: 4, 8, … 512, 1024 (parameter nfft). 
	Given the constraints of an 8-bit microcontroller, already 1024 data points consume substantial amounts of SRAM, so larger sample arrays are not reasonable for such constrained devices like MCUs. Four data points are rather few, but might be useful for some applications.
	

Note that there is a function kiss_fftc(); to handle complex input data. While FFT theory allows to use real input data in such algorithms as long as the output is interpreted nimbly, the real-data-only function kiss_fftr(); is plainly faster by an order of magnitude.
 
The device under test was an AVR128DB48 on a Curiosity nano evaluation kit. The device was programmed using MPLab X 5.50 via USB cable. 
 
## Measurements
The simplest approach to eavluate the speed of an algorithm on an AVR device is to examine a simulated device in MPLAB X: in Debug mode, the Stopwatch feature (Window->Debugging->Stopwatch) can be used in conjunction with break points. 
The number of consumed clock cycles for kiss_fftr(); can be converted into a "number of FFT per one million clock cycles", i.e. FFT/Mcyc, which makes it easy to scale performance with the application's clock settings.
This approach provides a quick and cheap orientation over the upper theoretical performance limit.

When the actual device is accessible, the duration of one FFT can be measured by observing the output level of a digital output pin with an oscilloscope or a network analyzer. Again, the absolute duration can be converted to FFT/MHz in order to compare performance, or to scale it with clock frequency.  
This method is recommended for applications where timing and CPU load are critical and estimates based on upper ceilings are insufficient.


## Results

The table shows the actual calculation duration of  kiss_fftr(cfg, cpx_in , cpx_out); converted to FFT operations per one million clock cycles. The values are either calculated from simulated clock cycles or converted from measured period durations of a toggled pin.

| _nfft_  |Simulation <br>FFT/Mcyc   |Measurement <br> FFT/MHz   |
|---|---|---|
|4	|1502	|1475|
|8	|812	|794|
|16	|300	|276|
|32	|165	|142|
|64	|60.5	|53.8|
|128	|32.4	|27.2|
|256	|12.6	|10.9|
|512	|6.6	|5.5|
|1024	|2.7	|2.3|
 
The base frequency of the physical device was not stabilized beyond stock parameters; while this may partly explain the fact that the measurements are about 2-15% slower than the simulations, other factors may play a role, too.

Interpretation
 
Example: with _nfft_ = 32 and 10MHz clock rate, the simulated AVR could provide about 1650 FFT conversions per second.  The direct measurement shows that the real number is closer to 1400 conversions per second. 
On the other hand, a device running at only 32.732Hz can still perform tens of FFTs per second for low values of _nfft_.

In practical applications, even the measured value still is an upper ceiling: for example, acquiring nfft ADC results takes time and is controlled by numerous parameters (sampling rate, clock configuration, sample duration, number of samples, waiting for trigger conditions). Appropriate windowing of the raw input data will use CPU cycles. Also, functions for handling and using the results from the FFT, such as activating an external device or waiting for acknowledge replies, may consume CPU cycles. In addition, and the device may be loaded with other, application-specific tasks.


## Result
It could be shown that an 8-bit MCU with AVR core is able to perform FFT on data arrays of reasonable sizes. Given the limited resources it is not surprising that the performance is not sufficient to replace spectrum analyzers.  On the other hand the FFT conversion rates presented here will suffice for many specific applications where an 8-bit MCU will be a natural choice.
	

## Sources
- Original kissFFT lib is here:
https://github.com/mborgerding/kissfft
	<br>(Note: "kiss-FFT" is a wrapper of kissFFT for Android, and gets a lot of search engine hits)
- Code example for MPLAB X and AVR128DB48 is  here:
https://bitbucket.microchip.com/projects/AN/repos/en_avr_ea_id02_fft_kissfft_mini_example
